// 参照：フリーランスエンジニア じゃけえさんブログ
// 【Java】値(プリミティブ)型と参照(オブジェクト)型の違いをコードと図で解説

// 1 値(プリミティブ)型とは
// 値型は以下８つ
// boolean	1bit
// byte	8bit
// char	16bit
// short	16bit
// int	32bit
// float	32bit
// long	64bit
// double	64bit
// ・特徴としては、全て変数のサイズ(bit)が決まっているということ
// ・規定のサイズを超える値を格納することはできません。逆に言うと適切な型を使わないと無駄にメモリを使うことになる

// 2 参照(オブジェクト)型とは
// 参照型はそれ以外の変数たちで、よく使うとこだと
// String
// 配列
// List系
// DtoやFormなどのクラス etc…
// など
// ・参照(オブジェクト)型の特徴は、変数に格納されているのは「値」そのものではなく、値がメモリのどこに格納されているかを示す「参照値」ということ
// （例：ロッカーの鍵）
// 実際に値が格納されているのはロッカーの中で、変数はロッカーの番号が書いた鍵のイメージ
// オブジェクトは場合によってはけっこうサイズが大きくなります。
// ロッカーを持ち運ぶのは大変ですけど鍵なら簡単に持ち運べます

// 参照：Qiita：https://qiita.com/hiroki-harada/items/cb6fa4affffab2019cde
// Javaのプリミティブ型と参照型について

// 1 プリミティブ(型)とは？
// ・Javaのデータ型の一つ
// ・Javaのいわゆる基本な型のことで、値型とも言う
// ・メモリのスタック領域に値が入っている
// [種類]
// ・全部で8種類。
// ・ビット数が大きいほど表現できる範囲は広い
// データ型	表現できる値や範囲	          ビット(bit)	具体例
// boolean	true, false	                  1	
// byte	-128 ~ 127 の整数	                8	
// char	\u0000 ~ \uFFFF のUnicode文字列	  16	
// short	-32768 ~ 32767 の整数	            16	
// int	整数	                              32	
// float	実数(単精度不動小数点数)            	32	2f, 100F
// long	整数	                            64	10l, 5L
// double	実数(倍精度不動小数点数)	          64	

// 2 参照型とは？
// ・Javaのデータ型の一つ
// ・Stringとか、配列とか、Listとかのこと
// ・メモリのピープ領域に変数の参照値が、スタック領域に参照値が指す値が入っている
// 最後の定義をもっと細かく書くと、newして生成したオブジェクト(≒インスタンス)はスタック領域に、そのオブジェクトへのポインタ（メモリ上のアドレス）は参照値としてピープ領域に代入される、とのこと(参考4 > プリミティブ型と参照型より)。

// 3 ラッパークラスとは？
// ・参照型に分類される、プリミティブ型たちの進化系クラス
// ・それぞれのクラスに、便利なメソッドが用意されている
// ・プリミティブ型っぽく振る舞うけど、中身はnullの可能性がある(なので、ヌルポに注意)
// プリミティブ型をラップしている(包んでいる)から、ラッパークラス！中身はプリミティブ型
// （表）
// プリミティブ型	ラッパークラス
// boolean	      Boolean
// byte	        Byte
// char	        Character
// short	        Short
// int	          Integer
// float	        Float
// long	        Long
// double	      Double
// 例えばIntegerなら、Integer.parseInt(String)で文字列をint型に変換、Integer.valueOf(int)でint型を文字列に変換するなど、色々用意されています

// 4 オートボクシング・アンボクシングとは？
// オートボクシング：プリミティブ型からラッパークラスへの自動変換
// アンボクシング  ：ラッパークラスからプリミティブ型への自動変換2
// ・プリミティブ型を自動でラップする( = 箱に入れる)からオートボクシング、その逆に箱から取り出すからアンボクシング
// (サンプルコード)
// // オートボクシング
// int numInt = 10;
// Integer numInteger = numInt;
// // アンボクシング
// Integer numInteger = new Integer(10);
// int numInt =  numInteger;
// オートボクシング
// ＝＝＞
// [プリミティブ型][ラッパークラス]
// ＜＝＝
// アンボクシング
// // オートボクシング
// int numInt = 10;
// Integer numInteger = new Integer(numInt);
// // または以下
// Integer numInteger = Integer.valueOf(numInt);
// // アンボクシング
// Integer numInteger = new Integer(10);
// int numInt =  numInteger.intValue();

// 参照：Qiita https://qiita.com/akitxxx/items/b7b15229f7582038fc93
// プリミティブ型と参照型の違い

// 1 プリミティブ型（基本データ型）と参照型
// 1_1 プリミティブ型とは
// 以下の8つがプリミティブ型
// 型	分類	bit数
// boolean	真偽値	1
// byte	整数	8
// short	整数	16
// char	文字	16
// int	整数	32
// float	小数	32
// long	整数	64
// double	小数	64
// ・プリミティブ型の変数宣言時は、宣言と同時に変数に値を格納できる。
// ・以下の変数aには、そのまま1という値が格納される。
// int a = 1;

// 2 参照型とは
// ・参照型は、上の8つ以外の型です。
// （例）Stringや配列などが参照型
// Hoge hoge = new Hoge();
// String str = "fuga";
// ・参照型では変数に値はそのまま格納されず、値が格納されたメモリの場所を格納します。

// 2 再代入で見る基本型と参照型の違い
// ・基本型と参照型では再代入での挙動で違いが出る
// 2_1 (例)サンプルコード：基本（プリミティブ）型
// int a = 1;
// int b = a; // bにはaの値：1が格納される
// a = 2;

// Systemout.println(a); // 2 が出力される
// Systemout.println(b); // 1 が出力される
// 2_2 (例)サンプルコード：参照（オブジェクト）型
// int[] a = {1, 2, 3};
// int[] b = a;
// a[0] = 0;

// Systemout.println(a[0]); // 0 が出力される
// Systemout.println(b[0]); // 0 が出力される
// ・参照型では上記のようになります。
// 基本型と同じような考え方では、b[0]は1を出力しそうな感じです。
// ですが、参照型では変数に格納されるのはデータが格納されたメモリの場所だけです。
// 配列a宣言時、aには{1, 2, 3}という配列の情報が格納されたメモリの場所情報が格納されます。
// 配列b宣言時、bにもaのもつ{1, 2, 3}という配列のあるメモリ上の場所を格納します。
// このとき、aもbも同じメモリの場所情報が入った変数となっています。
// a[0] = 0;では、aに格納されたメモリの場所にある配列{1, 2, 3}の0番目の値を0に置き換えます。これでメモリ上に格納された配列は{0, 2, 3}となりました。
// よって、bに格納されたメモリ上の場所から配列の0番目を見てみても、出力される値は0となります。