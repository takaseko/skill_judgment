// 参照：TechAcademy
// Javaの値渡しと参照渡しの使用方法について現役エンジニアが解説【初心者向け】

// 1 引数とは
// ・引数とはメソッドを呼び出す際にメソッドの内部の処理で使う値を渡す方法のことです。
// ・引数はメソッド名の後ろの()の中に設定します。
// ・引数の渡し方には、引数の種類によって値渡しと参照渡しの2種類の渡し方が存在増します。

// 2 値(プリミティブ)型とは
// ・値型とは、Javaでデータを扱う型の一つでメモリ領域に決められた分のサイズをあけることで情報の保持が可能
// ・値型はJavaには以下の8種類存在
// byte型(8ビット)
// short型(16ビット)
// int型(32ビット)
// long型(64ビット)
// float型(32ビット)
// double型(64ビット)
// char型(16ビット)
// boolean型(1ビット)
// ※例えばbyte型の場合だとメモリ領域に8ビット分領域を確保することができます。

// 2 参照型（オブジェクト型）とは
// ・参照型はデータが格納されているメモリ上の参照(アドレス)のコピーを保持している型
// ・値型に含まれなかったものはすべて参照型に含まれます

// 3 値渡しと参照渡しの違い
// ・値渡しと参照渡しの違いは 渡した変数の状態が変化するかという点
// 3_1 （例：値(プリミティブ)型サンプルコード）
// public static void main(String[] args) {
//   int num = 10;
//   test(num);
//   System.out.println(num);
// }

// public static void test(int num) {
//   num += 10;
//   System.out.println(num);
// }
// （実行結果）
// 20
// 10
// （解説）
// 上記は値渡しを使ったサンプルコード。
// mainメソッドは、値型のint型の変数numに10を代入。
// 次にtestメソッドの中に値渡しで変数numを渡しています。
// testメソッドの中では値渡しで受け取った引数にプラス10をしています。
// 結果、testメソッド内での出力は「20」と表示される。
// しかし、元のmainメソッドの出力は「10」のまま。
// 値渡しとは変数に格納されているデータの中身のみ渡して、その変数自体は書き換わらないことを意味します。

// 3_2 （例：参照型（オブジェクト型）サンプルコード）
// public static void main(String[] args) {
//   String[] array = {"おはようございます", "こんにちは", "こんばんは"};
//   test(array);
//   System.out.println(array[0]);
// }

// public static void test(String[] array) {
//   array[0] = "Hello";
//   System.out.println(array[0]);
// }
// （実行結果）
// Hello
// Hello
// （解説）
// 今回は、参照型であるString[]の変数arrayをtestメソッドに渡しています。
// testメソッドは中でString[]の0番目の要素を書き換えており、結果としてtestメソッドで出力し、String[]の0番目の値は書き換わった内容で出力されました。
// そして、mainメソッドの方でも同じくString[]の0番目を出力すると同じく書き換わった内容が出力されています。
// つまり、参照渡しで渡すと元の変数の内容も書き換わるということ

// 4 Javaの参照渡し（参照の値渡し）について
// 通常参照渡しとはデータの場所、アドレスを渡すことで変数の内容自体を書き換えることを指します。
// ※Javaの場合は参照渡しではなく参照の値渡しが可能
// （例：サンプルコード）
// public static void main(String[] args) {
//   String[] array = {"おはようございます", "こんにちは", "こんばんは"};
//   test(array);
//   System.out.println(array[0]);
// }

// public static void test(String[] array) {
//   array = new String[3];
//   array[0] = "Hello";
//   System.out.println(array[0]);
// }
// （実行結果）
// おはようございます
// Hello
// （解説）
// 先ほどの参照渡しと同じくString[]を渡しています。
// しかし、testメソッド側で書き換えた内容がmain側では反映されていません。
// これが参照の値渡しを意味します。
// 今回testメソッドのなかで引数に対して新たにString[]を初期化しました。
// 瞬間引数の参照する場所は引数としてわたっていたデータのアドレスではなく、新しく初期化したインスタンスが作られているアドレスを参照することになります。
// しかし、mainメソッドの変数は参照するアドレスは変わりません。
// 元の変数と引数とで参照するアドレスが変わったことになり、これがJavaにおける参照渡し

// 参照：じゃけえさんブログ
// Javaの参照渡しと値渡しについてこの世で1番分かり易く解説してみた

// 1 まずは値(プリミティブ)型と参照型について
// 1_1 値(プリミティブ)型とは
// 値型は以下の８つ
// boolean	1bit
// byte	8bit
// char	16bit
// short	16bit
// int	32bit
// float	32bit
// long	64bit
// double	64bit
// ・値型のイメージはあなたがフタの空いた段ボールを持っていて、その中に値を入れているイメージ。
// ・実際にそこに値がある。

// 1_2 参照（オブジェクト）型とは
// 参照型はそれ以外の変数たちで、よく使うとこ
// String
// 配列
// List系
// DtoやFormなどのクラス etc…
// など。
// ※実はそんなに難しくなくて、イメージとしてはロッカーの鍵を持っているイメージ
// （例：）実際に値が格納されているのはロッカーの中で、あなたはそのロッカーの番号が書かれた鍵を持っているだけのようなイメージ


// 2 値渡しと参照渡しの違いについて(Javaとか関係なく)
// ・『渡し』と言うくらいなのでファンクションなどに変数(値型or参照型)を渡すときの話
// （例：【値渡しの場合】）
// 段ボールを持ったまま中の値を確認してファンクション君に伝える
// ※あくまで伝えるだけです。段ボール大好き人間のあなたは段ボールを手放さない
// （例：【参照渡しの場合】）
// ロッカーの鍵をファンクション君に渡す
// ※ファンクション君を相当信用している。ロッカーの中身は好き放題いじられます。
// （例：【値渡しのソースコード】）
// //値型の変数を定義（段ボールの中身は1）
// int i = 1;
 
// //値渡しでファンクションを呼び出す（「段ボールの中は1だよー！」）
// addNumber(i);
 
// //変数の中を表示
// System.out.println("俺の値は" + i + "じゃ～！");  //俺の値は1じゃ～！
 
// /**
//  * ファンクション君
//  */
// private void addNumber(int i) {
    
//     //引数に1を足す
//     i = i + 1;
    
//     //変数の中を表示
//     System.out.println("俺の値は" + i + "じゃ～！");  //俺の値は2じゃ～！
// }
// ファンクションを呼び出す際に、段ボールの中身を伝えているだけなので、iの値がファンクションを呼び出した後も変わってないことが分かります。
// 段ボールフェチですからね。
// （例：【参照渡しのソースコード】）
// //参照型の変数を定義（ロッカーの中に"テスト用紙"を入れて鍵を保有）
// List<String> list = new ArrayList<String>();
// list.add("テスト用紙");
 
// //参照渡しでファンクションを呼び出す（ファンクション君に鍵を渡す「任せたゼ」）
// editList(list);
 
// //変数の中を表示
// System.out.println("ロッカーの中は" + list + "じゃ～！");  //ロッカーの中は[テスト用紙,カンペ]じゃ～！
 
// /**
//  * ファンクション君
//  */
// private void editList(List<String> list) {
    
//     //ロッカーの中にカンペを追加
//     list.add("カンペ");
    
//     //変数の中を表示
//     System.out.println("ロッカーの中は" + list + "じゃ～！");  //ロッカーの中は[テスト用紙,カンペ]じゃ～！
// }
// 鍵そのものをファンクションに渡しているので、ロッカーの中は自由にいじられ中身が変わる
// ロッカーの中を確認(println)したら優しいファンクション君がカンペを入れてくれてました。これでテストは無敵だ。
// これが一般的な値渡しと参照渡しの動作の違い

// 3 Javaは参照渡しではなく参照の値渡し
// ・上記では便宜上Javaのソースで『参照渡し』として、『ロッカーの鍵を渡す』と説明しましたが、これは嘘。
// ・実際にはJavaでは参照型の変数を渡す場合、『参照の値渡し』が行われています。

// 3_1 参照の値渡しとは
// 『参照渡し』を『ロッカーの鍵を渡す』ことだと例えるなら
// 『参照の値渡し』は『ロッカーの鍵に書かれているロッカー番号を伝えること』と言えます。
// （例：【参照の値渡しのソースコード】）結果は上記「参照渡し」と同じになる
// //参照型の変数を定義（ロッカーの中に"テスト用紙"を入れて鍵を保有）
// List<String> list = new ArrayList<String>();
// list.add("テスト用紙");
 
// //参照の値渡しでファンクションを呼び出す（ファンクション君に鍵に書いている番号を伝える「鍵は空けといたゼ」）
// editList(list);
 
// //変数の中を表示
// System.out.println("ロッカーの中は" + list + "じゃ～！");  //ロッカーの中は[テスト用紙,カンペ]じゃ～！
 
// /**
//  * ファンクション君
//  */
// private void editList(List<String> list) {
    
//     //ロッカーの中にカンペを追加
//     list.add("カンペ");
    
//     //変数の中を表示
//     System.out.println("ロッカーの中は" + list + "じゃ～！");  //ロッカーの中は[テスト用紙,カンペ]じゃ～！
// }

// 3_2 参照渡しと参照の値渡しで違いが起きる例
// //参照型の変数を定義
// List<String> list = new ArrayList<String>();
// list.add("テスト用紙");
 
// //参照の値渡しでファンクションを呼び出す
// editList(list);
 
// //変数の中を表示
// System.out.println("ロッカーの中は" + list + "じゃ～！");  //ロッカーの中は[テスト用紙]じゃ～！
 
// /**
//  * ファンクション君
//  */
// private void editList(List<String> list) {
    
//     //再度newする
//     list = new ArrayList<String>();
    
//     //ロッカーの中にテスト用紙とカンペを追加
//     list.add("テスト用紙part2");
//     list.add("カンペ");
    
//     //変数の中を表示
//     System.out.println("ロッカーの中は" + list + "じゃ～！");  //ロッカーの中は[テスト用紙part2,カンペ]じゃ～！
// }
// ロッカーの鍵の現物が無いとロッカーを初期化しようとしても駅員さんが許可してくれない、とイメージすると良い。
// 鍵がないとダメなのか…でもロッカー番号教えてもらっただけだしな…
// でもnewしろってうるさいからな…「そうだ！新しいロッカー申請すれば良いじゃん！
// と、Javaの参照の値渡しの場合こんなことが起こっている。
// ※因みに本当の参照渡しの場合(C#で明示的にrefを付ける等)は、鍵があるので同じロッカーを初期化して使いまわすのでどちらの出力結果も
// //ロッカーの中は[テスト用紙part2,カンペ]じゃ～！
// と表示されます。ロッカーを無駄遣いしなくて良い